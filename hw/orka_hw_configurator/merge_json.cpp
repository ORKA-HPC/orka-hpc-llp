/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */
#include <cctype> // std::tolower
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <stdlib.h> // realpath
#include <string>
#include <sys/stat.h>

#include <nlohmann/json.hpp>
#include <Support/CmdLine.h>
#include <Support/CmdLineUtil.h>

namespace support
{
struct cmdline
{
    using cmdline_options = std::vector<std::shared_ptr<cl::OptionBase>>;

    void add_cmdline_option( std::shared_ptr<cl::OptionBase> option )
    {
        options_.emplace_back(option);
    }

    void parse_cmd_line(int argc, char** argv)
    {
        for (auto& opt : options_)
        {
            cmd_.add(*opt);
        }

        auto args = std::vector<std::string>(argv + 1, argv + argc);
        cl::expandWildcards(args);
        cl::expandResponseFiles(args, cl::TokenizeUnix());

        cmd_.parse(args, allow_unknown_args);
    }

    // custom parser that runs realpath() and checks if valid
    struct fileparser : public cl::Parser<std::string>
    {
        void operator()(StringRef arg_name, StringRef arg, std::string& value)
        {
            try
            {
                std::string v = realpath(arg.data(), NULL);
                value = v;
            } catch (...)
            {
                std::cerr << "ERROR: Path/file does not exist!\n"
                    << "-" << arg_name.str() << " " << arg.str()
                    << std::endl;
                exit(1);
            }
        }
    };

    cmdline(int argc, char** argv)
    {
        add_cmdline_option( cl::makeOption<std::string&>(
                    fileparser(),
                    "settings",
                    cl::Desc("settings.json file generated by orka_hw_configurator"),
                    cl::Required,
                    cl::ArgRequired,
                    cl::init(this->settings_file)
                    ) );

        try
        {
            parse_cmd_line(argc, argv);
        }
        catch (...)
        {
            std::cout << cmd_.help(argv[0]) << '\n';
            throw;
        }
    }

    std::string settings_file;
    cmdline_options options_;
    cl::CmdLine cmd_;
    bool allow_unknown_args = false;
};

}

int main(int argc, char** argv)
{
    // get cmdline args
    support::cmdline cmd(argc, argv);

    std::cout << "orka_hw_configurator::merge_json: Trying to merge JSON files..." << std::endl;

    // get file locations from settings.json
    std::ifstream s;
    s.open(cmd.settings_file);
    if (!s.is_open())
    {
        std::cerr << "ERROR: Could not read settings.json. Aborting..." << std::endl;
        return 1;
    }
    nlohmann::json settings;
    s >> settings;
    s.close();
    std::string config_file = (std::string)settings["design_dir"] + "/" + (std::string)settings["json_filename"];
    std::string regmap_file = (std::string)settings["design_dir"] + "/" + "reg_map.json";
    std::string vendor = settings["vendor"];
    // convert to lowercase
    for(auto& c : vendor) {
        c = std::tolower(c);
    }

    // read json files
    nlohmann::json config, regmap;
    std::ifstream c, r;
    c.open(config_file);
    r.open(regmap_file);
    if (c.is_open() && r.is_open())
    {
        c >> config;
        r >> regmap;
    } else
    {
        std::cerr << "ERROR: Could not read JSON files. Aborting..." << std::endl;
        std::cerr << "Tried to open files:\n"
            << "config_file: " << config_file << "\n"
            << "regmap_file: " << regmap_file << std::endl;
        return 1;
    }
    c.close();
    r.close();

    for (auto& ip : regmap.items())
    {
        for (auto& fpga : config["FPGAs"])
        {
            for (auto& component : fpga["Components"])
            {
                if (std::string(component["name"]).find(ip.key()) != std::string::npos)
                {
                    if (vendor == "xilinx")
                    {
                        // only use component that contains "/SEG_{IP_NAME}_Reg" and discard AXI-MM blocks (starting with /{IP_NAME}/...
                        if (std::string(component["name"]).find("/SEG_" + ip.key() + "_Reg") != std::string::npos)
                        {
                            component.update(regmap[ip.key()]);
                        }
                    } else if (vendor == "intel")
                    {
                        if (std::string(component["name"]).find(ip.key()) != std::string::npos)
                        {
                            component.update(regmap[ip.key()]);
                        }
                    }
                } else if (std::string(component["name"]).find("SEG_axi_gpio") != std::string::npos)
                {
                    // insert registers for Xilinx GPIO IP
                    const nlohmann::json gpio_registers = {
                            {"registers", {
                                {
                                    {"addr", "0x0000"},
                                    {"name", "GPIO_DATA"}
                                },
                                {
                                    {"addr", "0x0004"},
                                    {"name", "GPIO_TRI"}
                                },
                                {
                                    {"addr", "0x0008"},
                                    {"name", "GPIO2_DATA"}
                                },
                                {
                                    {"addr", "0x000c"},
                                    {"name", "GPIO2_TRI"}
                                },
                                {
                                    {"addr", "0x0110"},
                                    {"bits", "32"},
                                    {"name", "GIER"}
                                },
                                {
                                    {"addr", "0x0120"},
                                    {"bits", "32"},
                                    {"name", "IP_ISR"}
                                },
                                {
                                    {"addr", "0x0128"},
                                    {"bits", "32"},
                                    {"name", "IP_IER"}
                                }
                            }}
                        };
                    component.update(gpio_registers);
                }
            }
        }
    }

    // write new config
    std::ofstream newconfig;
    newconfig.open(config_file);
    if (!newconfig.is_open())
    {
        std::cerr << "ERROR: New config could not be written" << std::endl;
        return 1;
    }
    newconfig << config.dump(4) << std::endl;
    newconfig.close();

    std::cout << "orka_hw_configurator::merge_json: JSON Files have been merged successfully!" << std::endl;

    return 0;
}
